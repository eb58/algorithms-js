<!doctype html>
<html lang="de">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    <title>Mandelbrot</title>
  </head>

  <body style="width: 1000px; margin: 0 auto">
    <div style="width: 800px; margin: 0 auto">
      <h1>Mandelbrot Set Viewer</h1>
      <div id="controls">
        <button onclick="resetView()" id="resetBtn">Zur√ºcksetzen</button>
        <button onclick="increaseIterations()" id="moreBtn">Mehr Details (+50 Iterationen)</button>
        <button onclick="decreaseIterations()" id="lessBtn">Weniger Details (-50 Iterationen)</button>
      </div>
      <canvas id="myCanvas" width="800" height="800"></canvas>
      <p style="text-align: center">Click the image to zoom in</p>
      <p style="text-align: center">
        Zoom: <span id="zoomLevel">1.0</span>x | Iterationen: <span id="iterations">100</span>
      </p>
    </div>
    <script>
      const timer = (start = performance.now()) => ({ elapsedTime: () => ((performance.now() - start) / 1000).toFixed(3) })
      const range = (n) => [...Array(n).keys()]
      const rand255 = () => Math.floor(Math.random() * 255)

      const NCOLORS = 1000
      const COLORS = range(NCOLORS).map(() => [rand255(), rand255(), rand255(), 255])
      const WHITE = [255, 255, 255, 255]

      const canvas = document.getElementById('myCanvas')
      const { width, height } = canvas

      const initialView = {
        centerX: -0.5,
        centerY: 0,
        width: 2.65,
        maxIterations: 100,
        zoomFactor: 1
      }
      let view = { ...initialView }

      const mandelbrot = (cx, cy, maxIterations = 100) => {
        let x = cx,
          y = cy,
          n = 0
        while (x * x + y * y <= 4 && n++ < maxIterations) {
          const xTemp = x * x - y * y + cx
          y = 2 * x * y + cy
          x = xTemp
        }
        return n >= maxIterations ? WHITE : COLORS[n % NCOLORS]
      }

      const computeMandelbrot = () => {
        const t = timer()
        const imageData = canvas.getContext('2d').getImageData(0, 0, width, height)
        const viewHeight = view.width * (height / width)
        for (let r = 0; r < height; r++)
          for (let c = 0; c < width; c++) {
            const x0 = view.centerX + ((r - width / 2) * view.width) / width
            const y0 = view.centerY + ((c - height / 2) * viewHeight) / height
            mandelbrot(x0, y0, view.maxIterations).forEach((n, idx) => (imageData.data[(c * width + r) * 4 + idx] = n))
          }
        canvas.getContext('2d').putImageData(imageData, 0, 0)
        console.log(t.elapsedTime())
        updateInfo()
      }

      const zoom = (event, factor = 2) => {
        const rect = canvas.getBoundingClientRect()
        const x = event.clientX - rect.left
        const y = event.clientY - rect.top
        const viewHeight = view.width * (canvas.height / canvas.width)
        const clickX = view.centerX + (x - canvas.width / 2) * (view.width / canvas.width)
        const clickY = view.centerY + (y - canvas.height / 2) * (viewHeight / canvas.height)
        view.width *= factor
        view.centerX = clickX
        view.centerY = clickY
        view.zoomFactor /= factor
        computeMandelbrot()
      }

      canvas.addEventListener('click', (e) => zoom(e, 0.5))
      canvas.addEventListener('dblclick', (e) => zoom(e, 2))

      const resetView = () => {
        view = { ...initialView }
        computeMandelbrot()
      }
      const increaseIterations = () => ((view.maxIterations += 50), computeMandelbrot())
      const decreaseIterations = () => ((view.maxIterations = Math.max(100, view.maxIterations - 50)), computeMandelbrot())
      const updateInfo = () => {
        document.getElementById('zoomLevel').textContent = view.zoomFactor.toFixed(2)
        document.getElementById('iterations').textContent = view.maxIterations
      }

      computeMandelbrot()
    </script>
  </body>
</html>
