<!doctype html>
<html lang="de">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    <title>Mandelbrot</title>
  </head>

  <body style="width: 1000px; margin: 0 auto">
    <div style="width: 800px; margin: 0 auto">
      <h1>Mandelbrot Set Viewer</h1>
      <div id="controls">
        <button onclick="resetView()">Zur√ºcksetzen</button>
        <button onclick="increaseIterations()">Mehr Details (+50 Iterationen)</button>
        <button onclick="decreaseIterations()">Weniger Details (-50 Iterationen)</button>
        <button onclick="changeColScheme()">Farbschema</button>
      </div>
      <canvas id="myCanvas" width="800" height="800"></canvas>
      <p style="text-align: center">Click the image to zoom in</p>
      <p style="text-align: center">Zoom: <span id="zoomLevel">1.0</span>x | Iterationen: <span id="iterations">100</span></p>
    </div>
    <script>
      const timer = (start = performance.now()) => ({ elapsedTime: () => ((performance.now() - start) / 1000).toFixed(3) })
      const range = (n) => [...Array(n).keys()]
      const rand255 = () => Math.floor(Math.random() * 255)

      const NCOLORS = 1000
      const COLORS = range(NCOLORS).map(() => [rand255(), rand255(), rand255(), 255])
      const WHITE = [255, 255, 255, 255]
      const BLACK = [0, 0, 0, 255]

      const canvas = document.getElementById('myCanvas')
      const { width, height } = canvas

      const initialView = {
        centerX: -0.5,
        centerY: 0,
        width: 2.65,
        maxIterations: 100,
        zoomFactor: 1
      }
      let view = { ...initialView }

      const getColorSimple = (n, maxIterations) => (n >= maxIterations ? WHITE : COLORS[n % NCOLORS])
      const getColor = (n, maxIterations) => {
        if (n >= maxIterations) return BLACK

        const ratio = n / maxIterations
        const hue = ratio * 360
        const saturation = 100
        const lightness = ratio < 0.5 ? 50 * ratio * 2 : 50

        const h = hue / 60
        const c = ((1 - Math.abs((2 * lightness) / 100 - 1)) * saturation) / 100
        const x = c * (1 - Math.abs((h % 2) - 1))
        const m = lightness / 100 - c / 2

        let r, g, b
        if (h < 1) {
          r = c
          g = x
          b = 0
        } else if (h < 2) {
          r = x
          g = c
          b = 0
        } else if (h < 3) {
          r = 0
          g = c
          b = x
        } else if (h < 4) {
          r = 0
          g = x
          b = c
        } else if (h < 5) {
          r = x
          g = 0
          b = c
        } else {
          r = c
          g = 0
          b = x
        }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255), 255]
      }

      let getCol = getColorSimple
      const mandelbrot = (cx, cy, maxIterations = 100) => {
        let [x, y, n] = [cx, cy, 0]
        while (x * x + y * y <= 4 && n++ < maxIterations) {
          const xTemp = x * x - y * y + cx
          y = 2 * x * y + cy
          x = xTemp
        }
        return getCol(n, maxIterations) // n >= maxIterations ? WHITE : COLORS[n % NCOLORS]
      }

      const computeMandelbrot = () => {
        const t = timer()
        const imageData = canvas.getContext('2d').getImageData(0, 0, width, height)
        const viewHeight = view.width * (height / width)
        for (let r = 0; r < height; r++)
          for (let c = 0; c < width; c++) {
            const x0 = view.centerX + ((r - width / 2) * view.width) / width
            const y0 = view.centerY + ((c - height / 2) * viewHeight) / height
            mandelbrot(x0, y0, view.maxIterations).forEach((n, idx) => (imageData.data[(c * width + r) * 4 + idx] = n))
          }
        canvas.getContext('2d').putImageData(imageData, 0, 0)
        console.log(t.elapsedTime())
        updateInfo()
      }

      const zoom = (event, factor = 2) => {
        const rect = canvas.getBoundingClientRect()
        const x = event.clientX - rect.left
        const y = event.clientY - rect.top
        const viewHeight = view.width * (canvas.height / canvas.width)
        const clickX = view.centerX + (x - canvas.width / 2) * (view.width / canvas.width)
        const clickY = view.centerY + (y - canvas.height / 2) * (viewHeight / canvas.height)
        view.width *= factor
        view.centerX = clickX
        view.centerY = clickY
        view.zoomFactor /= factor
        computeMandelbrot()
      }


      // ui actions
      canvas.addEventListener('click', (e) => zoom(e, 0.5))
      canvas.addEventListener('dblclick', (e) => zoom(e, 2))
      const resetView = () => ((view = { ...initialView }), computeMandelbrot())
      const increaseIterations = () => ((view.maxIterations += 50), computeMandelbrot())
      const decreaseIterations = () => ((view.maxIterations = Math.max(100, view.maxIterations - 50)), computeMandelbrot())
      const changeColScheme = () => ((getCol = getCol === getColorSimple ? getColor : getColorSimple), computeMandelbrot())
      const updateInfo = () => {
        document.getElementById('zoomLevel').textContent = view.zoomFactor
        document.getElementById('iterations').textContent = view.maxIterations
      }

      computeMandelbrot()
    </script>
  </body>
</html>
