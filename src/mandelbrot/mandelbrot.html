<!doctype html>
<html lang="de">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    <title>Mandelbrot</title>
  </head>

  <body style="width: 1000px; margin: 0 auto">
    <div style="width: 800px; margin: 0 auto">
      <h1>Mandelbrot Set Viewer</h1>
      <div id="controls">
        <button onclick="resetView()">Zur√ºcksetzen</button>
        <button onclick="increaseIterations()">Mehr Details (+100 Iterationen)</button>
        <button onclick="decreaseIterations()">Weniger Details (-100 Iterationen)</button>
        <button onclick="changeColScheme()">Farbschema</button>
      </div>
      <canvas id="myCanvas" width="800" height="800"></canvas>
      <p style="text-align: center">Click the image to zoom in</p>
      <p style="text-align: center">Zoom: <span id="zoomLevel">1.0</span>x | Iterationen: <span id="iterations">100</span></p>
    </div>
    <script>
      const worker = new Worker('mandelbrot.worker.js')
      const timer = (start = performance.now()) => ({ elapsedTime: () => ((performance.now() - start) / 1000).toFixed(3) })
      const range = (n) => [...Array(n).keys()]
      const rand255 = () => Math.floor(Math.random() * 255)

      const NCOLORS = 1000
      const COLORS = range(NCOLORS).map(() => [rand255(), rand255(), rand255(), 255])
      const WHITE = [255, 255, 255, 255]
      const BLACK = [0, 0, 0, 255]

      const canvas = document.getElementById('myCanvas')
      const { width, height } = canvas
      const ctx = canvas.getContext('2d')
      const imageData = ctx.getImageData(0, 0, width, height)

      const initialView = {
        centerX: -0.5,
        centerY: 0,
        width: 2.65,
        maxIterations: 100,
        zoomFactor: 1
      }
      let view = { ...initialView }

      const getColorSimple = (n, maxIterations) => (n >= maxIterations ? WHITE : COLORS[n % NCOLORS])
      const getColor = (n, maxIterations) => {
        if (n >= maxIterations) return BLACK

        const ratio = n / maxIterations
        const hue = ratio * 360
        const saturation = 100
        const lightness = ratio < 0.5 ? 50 * ratio * 2 : 50

        const h = hue / 60
        const c = ((1 - Math.abs((2 * lightness) / 100 - 1)) * saturation) / 100
        const x = c * (1 - Math.abs((h % 2) - 1))
        const m = lightness / 100 - c / 2

        let r, g, b
        if (h < 1) {
          r = c
          g = x
          b = 0
        } else if (h < 2) {
          r = x
          g = c
          b = 0
        } else if (h < 3) {
          r = 0
          g = c
          b = x
        } else if (h < 4) {
          r = 0
          g = x
          b = c
        } else if (h < 5) {
          r = x
          g = 0
          b = c
        } else {
          r = c
          g = 0
          b = x
        }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255), 255]
      }

      let getCol = getColorSimple

      const computeMandelbrot = () => {
        updateInfo()

        const t = timer()
        const viewHeight = view.width * (height / width)
        const chunkSize = Math.trunc(height / 16) // rows per chunk

        for (let currentRow = 0; currentRow < height/ 2; currentRow += chunkSize) {
          const endRow = Math.min(height, currentRow + chunkSize)
          worker.postMessage({
            view,
            width,
            height,
            viewHeight,
            currentRow,
            endRow,
            chunkSize,
            maxIterations: view.maxIterations
          })

          let accTime = 0
          worker.onmessage = (data) => {
            accTime += data.data.elapsedTime
            console.log('AAA', t.elapsedTime(), data.data.elapsedTime.toFixed(3), accTime.toFixed(3))
            data.data.result.forEach((nIter, i1) => getCol(nIter, view.maxIterations).forEach((cc,idx)=> (imageData.data[i1 * 4 + idx] = cc)))
            ctx.putImageData(imageData, 0, data.data.chunk)
            console.log('BBB', t.elapsedTime())
          }
        }
      }

      const zoom = (event, factor = 2) => {
        const rect = canvas.getBoundingClientRect()
        const x = event.clientX - rect.left
        const y = event.clientY - rect.top
        const viewHeight = view.width * (canvas.height / canvas.width)
        const clickX = view.centerX + (x - canvas.width / 2) * (view.width / canvas.width)
        const clickY = view.centerY + (y - canvas.height / 2) * (viewHeight / canvas.height)
        view.width *= factor
        view.centerX = clickX
        view.centerY = clickY
        view.zoomFactor /= factor
        computeMandelbrot()
      }

      // ui actions
      canvas.addEventListener('click', (e) => zoom(e, 0.5))
      canvas.addEventListener('dblclick', (e) => zoom(e, 2))
      const resetView = () => ((view = { ...initialView }), computeMandelbrot())
      const increaseIterations = () => ((view.maxIterations += 100), computeMandelbrot())
      const decreaseIterations = () => ((view.maxIterations = Math.max(100, view.maxIterations - 100)), computeMandelbrot())
      const changeColScheme = () => ((getCol = getCol === getColorSimple ? getColor : getColorSimple), computeMandelbrot())
      const updateInfo = () => {
        document.getElementById('zoomLevel').textContent = view.zoomFactor
        document.getElementById('iterations').textContent = view.maxIterations
      }

      // start
      computeMandelbrot()
    </script>
  </body>
</html>
